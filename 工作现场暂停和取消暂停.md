我们需要在保持足够的运行工作线程以利用可用的硬件并行性和暂停过多的运行工作线程以节省CPU资源和功率之间取得平衡。
这并不简单，原因有两个：  
- 调度程序状态是有意分布的（特别是每 P 个工作队列），因此不可能在快速路径上计算全局谓词；  
- 为了优化线程管理，我们需要预知未来（如果不久的将来会有新的goroutine准备好，则不要暂停工作线程）。  
三种被拒绝但效果不佳的方法： 1. 集中所有调度程序状态（会抑制可扩展性）。 2. 直接 goroutine 切换。也就是说，当我们准备好一个新的 goroutine 并且有一个空闲的 P 时，取消一个线程并将线程和 goroutine 移交给它。这将导致线程状态颠簸，因为准备好 goroutine 的线程可能在下一刻停止工作，我们需要将其停放。此外，它会破坏计算的局部性，因为我们想在同一个线程上保留依赖的 goroutine；并引入额外的延迟。 3. 当我们准备好一个 goroutine 并且有一个空闲的 P 时，取消一个额外的线程，但不要进行切换。这将导致过多的线程停放/取消停放，因为额外的线程将立即停放而没有发现任何工作要做。当前的方法：当我们准备好一个 goroutine 时，如果 (1) 有一个空闲的 P 并且没有“旋转”的工作线程，我们会取消一个额外的线程。如果工作线程没有本地工作并且在全局运行队列/ netpoller 中没有找到工作，则认为工作线程正在旋转；旋转状态在 m.spinning 和 sched.nmspinning 中表示。以这种方式释放的线程也被认为是旋转的；我们不进行 goroutine 切换，因此这些线程最初无法工作。旋转线程在停车前会在 per-P 运行队列中进行一些旋转寻找工作。如果一个自旋线程找到工作，它将自己脱离自旋状态并继续执行。如果它没有找到工作，它会自行退出旋转状态，然后停车。如果至少有一个旋转线程（sched.nmspinning>1），我们在准备 goroutine 时不会取消新线程。为了弥补这一点，如果最后一个纺纱线程找到工作并停止纺纱，它必须解开一个新的纺纱线程。这种方法消除了不合理的线程释放峰值，但同时保证了最终的最大 CPU 并行利用率。主要的实现复杂性是我们需要在自旋->非自旋线程转换过程中非常小心。这种转换可能会随着新 goroutine 的提交而竞争，并且其中一部分或另一部分需要解除另一个工作线程的停放。如果他们都未能做到这一点，我们最终可能会出现半持久的 CPU 未充分利用。 goroutine 准备的一般模式是：提交一个 goroutine 到本地工作队列，#StoreLoad 样式的内存屏障，检查 sched.nmspinning。 spin->non-spinning 转换的一般模式是：减少 nmspinning，#StoreLoad 样式的内存屏障，检查所有 per-P 工作队列是否有新工作。请注意，所有这些复杂性都不适用于全局运行队列，因为我们在提交到全局队列时不会马虎地取消线程停放。另请参阅 nmspinning 操作的注释。
